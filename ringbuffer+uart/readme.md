- #### 镜像位的设计：写入镜像位write_mirror，读取镜像位read_mirror

​    当前两个镜像位的状态可以表示缓冲区的状态 -- 缓冲区空、缓冲区满、缓冲区非满
​    根据两个镜像位的相对值，判断缓冲区状态
​    缓冲区空：write_index = read_index      write_mirror = read_mirror
​    缓冲区满：write_index = read_index      write_mirror != read_mirror
​    缓冲区非满：write_index != read_index   

镜像位的变化：默认初始化读、写镜像位都为0
    write_mirror：

- #### 几种写数据的情况：

（1）非覆盖式写指定长度的数据，写入一次的数据的长度永远被限制 -- 小于剩余空闲位置的大小。
    然后将写入分为两种情况，根据是否需要重头写入--也就是判断写入指针右侧的空间大小是否足够

        1. 足够的话则直接写入，并更新写入指针位置；
                2. 如果右侧的空间不够，则将写入指针位置重置为0，从头开始写入剩余的字节；
            因为涉及从头开始重新写入，所以会触发写镜像位变化  write_mirror: 0 -> 1
            （即使这里写镜像位变化，写位置没有重新追上读位置的话是不会影响后面状态判断的，因为没追上的话再次写入操作时使用的是 “一般写入逻辑”）
                3. 如果写入位置追上读位置，那么write_index = read_index重合了，读镜像并没有改变，所以状态会判断为FULL
            （这里没有考虑边写边读的情况，如果编写边读，当读位置也超过了一次缓冲区大小后，读镜像也会翻转一次--read_mirror: 0 -> 1
            如果继续读并且追上了写位置，此时读镜像和写镜像相同，表示为空的状态；如果不继续读，而是写大量数据，然后反转一次 write_mirror: 1 -> 0
            并且追上了读位置，因为写翻转了两次，写和读镜像不同--追上后表示为满状态）
            （简单理解为跑步套圈，只要 “读” 不被完整的套了一圈，它会继续跑，并且在归零的位置，镜像翻转一次，保证和写镜像一致。一致的话就说明没有被
            完整的套了一圈 -- 因为套了一圈后写镜像会多翻转一次，导致读写镜像不同）

（2）覆盖式写指定长度的数据,长度限制为缓冲区大小，而非剩余空闲位置大小

